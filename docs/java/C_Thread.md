[TOC]

# 进程、线程、协成

## 参考

- [进程、线程与协程傻傻分不清](https://mp.weixin.qq.com/s/jhOSjVyRA6rNKqVT2pKMIQ)

# 内核态 vs 用户态

- 低权限的资源范围较小，高权限的资源范围更大。用户态与内核态只是不同权限的资源范围。
- 用户态与内核态的概念就是 CPU 指令集权限的区别
    - 执行内核空间的代码，具有 ring0 保护级别，有对硬件的所有操作权限，可以执行所有 CPU 指令集，访问任意地址的内存，在内核模式下的任何异常都是灾难性的，将会导致整台机器停机
    - 在用户模式下，具有 ring3 保护级别，代码没有对硬件的直接控制权限，也不能直接访问地址的内存，程序是通过调用系统接口(System Call APIs)
      来达到访问硬件和内存，在这种保护模式下，即时程序发生崩溃也是可以恢复的，在电脑上大部分程序都是在，用户模式下运行的

![img.png](../../../../resources/image/concurrency/内核态&用户态.png)

- 从上图我们可以看出来通过系统调用将Linux整个体系分为用户态和内核态，为了使应用程序访问到内核的资源，如CPU、内存、I/O，内核必须提供一组通用的访问接口，这些接口就叫**系统调用**。
- 库函数就是屏蔽这些复杂的底层实现细节，减轻程序员的负担，从而更加关注上层的逻辑实现，它**对系统调用进行封装，提供简单的基本接口给程序员**。
- Shell顾名思义，就是外壳的意思，就好像把内核包裹起来的外壳，**它是一种特殊的应用程序，俗称命令行**。Shell也是可编程的，它有标准的Shell语法，符合其语法的文本叫Shell脚本，很多人都会用Shell
  脚本实现一些常用的功能，可以提高工作效率。

## 用户态与内核态切换

### 切换开销

- 保留用户态现场（上下文、寄存器、用户栈等）
- 复制用户态参数，用户栈切到内核栈，进入内核态
- 额外的检查（因为内核代码对用户不信任）
- 执行内核态代码
- 复制内核态代码执行结果，回到用户态
- 恢复用户态现场（上下文、寄存器、用户栈等）

## 何时切换

- 系统调用：用户态进程主动切换到内核态的方式，用户态进程通过系统调用向操作系统申请资源完成工作，例如 fork（）就是一个创建新进程的系统调用，系统调用的机制核心使用了操作系统为用户特别开放的一个中断来实现，如Linux 的
  interrupt 中断，也可以称为软中断
- 异常：当 CPU 在执行用户态的进程时，发生了一些没有预知的异常，这时当前运行进程会切换到处理此异常的内核相关进程中，也就是切换到了内核态，如缺页异常
- 中断：当 CPU 在执行用户态的进程时，外围设备完成用户请求的操作后，会向 CPU 发出相应的中断信号，这时 CPU
  会暂停执行下一条即将要执行的指令，转到与中断信号对应的处理程序去执行，也就是切换到了内核态。如硬盘读写操作完成，系统会切换到硬盘读写的中断处理程序中执行后边的操作等。

## 参考

- [从根上理解用户态与用户态](https://juejin.cn/post/6923863670132850701)

# Java Thread

## Thread.start()

![img.png](../../../../resources/image/concurrency/线程创建与启动流程.png)

- [Thread执行流程图](https://www.processon.com/view/link/5f02ed9e6376891e81fec8d5)

## Java线程的生命周期

![img.png](../../../../resources/image/concurrency/JavaThreadLiftCycle.png)

- Thread.sleep(millis)
    - 调用 sleep 会让当前线程从 Running 进入 TIMED_WAITING 状态，**不会释放对象锁**
    - 其它线程可以使用 interrupt 方法打断正在睡眠的线程，这时 sleep 方法会抛出 InterruptedException，并且**会清除中断标志**
    - 睡眠结束后的线程未必会立刻得到执行
    - sleep当传入参数为0时，和yield相同
- Thread.yield()
    - yield会**释放CPU资源**，让当前线程从 Running 进入 Runnable状态，让优先级更高 （至少是相同）的线程获得执行机会，**不会释放对象锁**
    - 具体的实现依赖于操作系统的任务调度器
- join()
    - 等待调用join方法的线程结束之后，程序再继续执行，一般用于等待异步线程执行完结果之 后才能继续运行的场景。
- stop()
    - stop会释放对象锁，可能会造成数据不一致。
    - stop()方法已经被jdk废弃，原因就是stop()方法太过于暴力，强行把执行到一半的线程终止。
- Java线程的中断机制
    - 中断机制是一 种协作机制，也就是说通过中断并不能直接终止另一个线程，而需要被中断的线程自己处理。
    - interrupt()： 将线程的中断标志位设置为true，不会停止线程
    - isInterrupted(): 判断当前线程的中断标志位是否为true，不会清除中断标志位
    - Thread.interrupted(): 判断当前线程的中断标志位是否为true，并清除中断标志 位，重置为fasle
    - sleep()可以被中断 抛出中断异常：sleep interrupted， **清除中断标志位**
    - wait()可以被中断 抛出中断异常：InterruptedException， **清除中断标志位**

## Java 线程间通信

- volatile
    - 可见性、有序性，禁止指令重排。其中可见性就是可以让线程之间进行通信。
- 等待唤醒机制
    - LockSupport.park() / LockSupport.unpark() LockSupport是JDK中用来实现线程阻塞和唤醒的工具，线程调用park则等待“许可”，调用
      unpark则为指定线程提供“许可”。使用它可以在任何场合使线程阻塞，可以指定任何线程进行 唤醒，并且不用担心阻塞和唤醒操作的顺序，但要注意连续多次唤醒的效果和一次唤醒是一样的。
    - wait()/notify()、notifyAll() 在一个线程内调用该线程锁对象的wait方法，线程将进入等待队列进行等待直到被唤醒。
- 管道输入输出流
    - 管道输入/输出流和普通的文件输入/输出流或者网络输入/输出流不同之处在于，它主要用于线程 之间的数据传输，而传输的媒介为内存
    - 管道输入/输出流主要包括了如下4种具体实现： PipedOutputStream/PipedInputStream 面向字节，PipedReader/PipedWriter 面向字符
- join()
    - join 可以理解成是线程合并，当在一个线程调用另一个线程的join方法时，当前线程阻塞等待被调用 join 方法的线程执行完毕才能继续执行
    - join 的实现其实是基于等待通知机制的。

## 参考

- [java-thread-lifecycle](https://www.baeldung.com/java-thread-lifecycle)