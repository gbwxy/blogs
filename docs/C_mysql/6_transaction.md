[TOC]

# 事务

## ACID 

- 原子性(Atomicity) ：事务是一个原子操作单元,其对数据的修改,要么全都执行,要么全都不执行。

- 一致性(Consistent) ：在事务开始和完成时,数据都必须保持一致状态。这意味着所有相关的数据规则都必须应用于事务的修改,以保持数据的完整性。

- 隔离性(Isolation) ：数据库系统提供一定的隔离机制,保证事务在不受外部并发操作影响的“独立”环境执行。这意味着事务处理过程中的中间状态对外部是不可见的,反之亦然。

- 持久性(Durable) ：事务完成之后,它对于数据的修改是永久性的,即使出现系统故障也能够保持。

## 并发问题

- 更新丢失 Lost Update 或脏写 Dirty Write

  当两个或多个事务选择同一行，然后基于最初选定的值更新该行时，由于每个事务都不知道其他事务的存在，就会发生丢失更新问题–最后的更新覆盖了由其他事务所做的更新。

- 脏读 Dirty Read

  一个事务正在对一条记录做修改，在这个事务完成并提交前，另一个事务也来读取同一条记录，如果不加控制，第二个事务读取了这些“脏”数据，并据此作进一步的处理，就会产生未提交的数据依赖关系。这种现象被形象的叫做“脏读”。

  一句话：事务A读取到了事务B已经修改但尚未提交的数据，还在这个数据基础上做了操作。此时，如果B事务回滚，A读取的数据无效，不符合一致性要求。

- 不可重读 Non-Repeatable Read

  一个事务在读取某些数据后的某个时间，再次读取以前读过的数据，却发现其读出的数据已经发生了改变、或某些记录已经被删除了！这种现象就叫做“不可重复读”。

  一句话：事务A内部的相同查询语句在不同时刻读出的结果不一致，不符合隔离性

- 幻读 Phantom Read

  一个事务按相同的查询条件重新读取以前检索过的数据，却发现其他事务插入了满足其查询条件的新数据，这种现象就称为“幻读”。

  一句话：事务A读取到了事务B提交的新增数据，不符合隔离性

## 事务隔离级别

| 隔离级别                  | 脏读 Dirty Read | 不可重复读 NonRepeatable Read | 幻读Phantom Read |
| ------------------------- | --------------- | ----------------------------- | ---------------- |
| 读未提交 Read Uncommitted | 可能            | 可能                          | 可能             |
| 读已提交 Read Committed   | 不可能          | 可能                          | 可能             |
| 可重复读 Repeatable Read  | 不可能          | 不可能                        | 可能             |
| 可串行化 Serializable     | 不可能          | 不可能                        | 不可能           |

# 锁

## 锁分类

- 从性能上分为**乐观锁(用版本对比来实现)**和**悲观锁**

- 从对数据库操作的类型分，分为**读锁和写锁(都属于悲观锁)**
  - **读锁 - 共享锁，S锁 Shared**：针对同一份数据，多个读操作可以同时进行而不会互相影响
  - **写锁 - 排它锁，X锁 eXclusive**：当前写操作没有完成前，它会阻断其他写锁和读锁

- 从对数据操作的粒度分，分为**表锁**和**行锁**

## MySQL 锁

- **MyISAM 只有表锁**。在执行查询语句SELECT前，会自动给涉及的所有表加读锁，在执行update、insert、delete操作会自动给涉及的表加写锁。

- **InnoDB实现了表锁和行锁**。在执行查询语句SELECT时(非串行隔离级别)，不会加锁。但是update、insert、delete操作会加行锁。**简而言之，就是读锁会阻塞写，但是不会阻塞读。而写锁则会把读和写都阻塞。**

### 无索引行锁会升级为表锁

**InnoDB的行锁是针对索引加的锁，不是针对记录加的锁。并且该索引不能失效，否则都会从行锁升级为表锁。**

### 间隙锁(Gap Lock)

- 间隙锁，锁的就是两个值之间的空隙。**事务隔离级别是 repeatable-read 时间隙锁生效。**
- **间隙锁可以一定程度上解决幻读问题**

### 临键锁(Next-key Locks)

- Next-Key Locks是行锁与间隙锁的组合

## 锁优化建议

- 尽可能让所有数据检索都通过索引来完成，避免无索引行锁升级为表锁

- 合理设计索引，尽量缩小锁的范围

- 尽可能减少检索条件范围，避免间隙锁

- 尽量控制事务大小，减少锁定资源量和时间长度，涉及事务加锁的sql尽量放在事务最后执行

- 尽可能低级别事务隔离













