# 跟谁学一面
1. 4-5分钟自我介绍、聊天

2. HashMap 怎么能让我们快速定位 key 和 value 的存储位置的

3. HashMap 扩容机制

4. ConcurrentHashMap 怎么保证的线程安全

5. 用过哪些锁

6. Synchronized 和 ReentrantLock 的异同
- 两者都是可重⼊锁
- synchronized 依赖于 JVM ⽽ ReentrantLock 依赖于 API
- ReentrantLock ⽐ synchronized 增加了⼀些⾼级功能：①等待可中断； ②可实现公平锁； ③可实现选择性通知（锁可以绑定多个条件）
	- ReentrantLock提供了⼀种能够中断等待锁的线程的机制，通过lock.lockInterruptibly()来实现这个机制
	- ReentrantLock可以指定是公平锁还是⾮公平锁。⽽synchronized只能是⾮公平锁。
	- synchronized关键字与wait()和notify()/notifyAll()⽅法相结合可以实现等待/通知机制
	- ReentrantLock类当然也可以实现等待/通知机制，但是需要借助于Condition接⼝与newCondition() ⽅法。线程对象可以注册在指定的Condition中，从⽽可以有选择性的进⾏线程通知，在调度线程上更加灵活。 在使⽤notify()/notifyAll()⽅法进⾏通知时，被通知的线程是由 JVM 选择的，⽤ReentrantLock类结合Condition实例可以实现“选择性通知” 。
- synchronzied锁的是对象，锁是保存在对象头里面的，根据对象头数据来标识是否有线程获得锁/争抢锁；ReentrantLock锁的是线程，根据进入的线程和int类型的state标识锁的获得/争抢。

7. ReentrantLock 更灵活，体现在哪？
8. synchronized关键字和volatile关键字⽐较 
- volatile关键字是线程同步的轻量级实现，所以volatile性能肯定⽐synchronized关键字要好。但是volatile关键字只能⽤于变量⽽synchronized关键字可以修饰⽅法以及代码块。
- synchronized关键字在JavaSE1.6之后进⾏了主要包括为了减少获得锁和释放锁带来的性能消耗⽽引⼊的偏向锁和轻量级锁以及其它各种优化之后执⾏效率有了显著提升， 实际开发中使⽤synchronized 关键字的场景还是更多⼀些。
- 多线程访问volatile关键字不会发⽣阻塞，⽽synchronized关键字可能会发⽣阻塞
- volatile关键字能保证数据的可⻅性，但不能保证数据的原⼦性。 synchronized关键字两者都能保证。
- volatile关键字主要⽤于解决变量在多个线程之间的可⻅性，⽽ synchronized关键字解决的是多个线程之间访问资源的同步性。


8.  JDK1.6 之后的synchronized 关键字底层做了哪些优化
锁主要存在四中状态，依次是：无锁状态、偏向锁状态、轻量级锁状态、重量级锁状态，他们会随着竞争的激烈而逐渐升级。注意锁可以升级不可降级，这种策略是为了提高获得锁和释放锁的效率。
①偏向锁
- 偏向锁的“偏”就是偏心的偏，它的意思是会偏向于第一个获得它的线程，如果在接下来的执行中，该锁没有被其他线程获取，那么持有偏向锁的线程就不需要进行同步！
- 引入偏向锁的目的和引入轻量级锁的目的很像，他们都是为了没有多线程竞争的前提下，减少传统的重量级锁使用操作系统互斥量产生的性能消耗。但是不同是：轻量级锁在无竞争的情况下使用 CAS 操作去代替使用互斥量。而偏向锁在无竞争的情况下会把整个同步都消除掉。
② 轻量级锁
- 倘若偏向锁失败，虚拟机并不会立即升级为重量级锁，它还会尝试使用一种称为轻量级锁的优化手段
- 轻量级锁不是为了代替重量级锁，它的本意是在没有多线程竞争的前提下，减少传统的重量级锁使用操作系统互斥量产生的性能消耗，因为使用轻量级锁时，不需要申请互斥量。另外，轻量级锁的加锁和解锁都用到了CAS操作。
③  自旋锁和自适应自旋
- 轻量级锁失败后，虚拟机为了避免线程真实地在操作系统层面挂起，还会进行一项称为自旋锁的优化手段。
- 互斥同步对性能最大的影响就是阻塞的实现，因为挂起线程/恢复线程的操作都需要转入内核态中完成（用户态转换到内核态会耗费时间）
- 一般线程持有锁的时间都不是太长，所以仅仅为了这一点时间去挂起线程/恢复线程是得不偿失的。 所以，虚拟机的开发团队就这样去考虑：“我们能不能让后面来的请求获取锁的线程等待一会而不被挂起呢？看看持有锁的线程是否很快就会释放锁”。为了让一个线程等待，我们只需要让线程执行一个忙循环（自旋），这项技术就叫做自旋。
- 在 JDK1.6 中引入了自适应的自旋锁。自适应的自旋锁带来的改进就是：自旋的时间不在固定了，而是和前一次同一个锁上的自旋时间以及锁的拥有者的状态来决定，虚拟机变得越来越“聪明”了。
④ 锁消除
- 锁消除理解起来很简单，它指的就是虚拟机即使编译器在运行时，如果检测到那些共享数据不可能存在竞争，那么就执行锁消除。锁消除可以节省毫无意义的请求锁的时间。
⑤ 锁粗化
- 原则上，我们再编写代码的时候，总是推荐将同步快的作用范围限制得尽量小——只在共享数据的实际作用域才进行同步，这样是为了使得需要同步的操作数量尽可能变小，如果存在锁竞争，那等待线程也能尽快拿到锁。

8. 介绍一个最得意的项目：分布式最终一致性方案、Redis缓存架构与规范、分布式id生成器

9. MySQL 中 SQL 优化用过哪些？
- explain 分析慢查询
	- 开启慢查询日志：set global slow_query_log=1; (重启会失效)；永久设置慢查询日志开启，以及设置慢查询日志时间临界点。linux中，mysql配置文件一般默认在 /etc/my.cnf 更改对应参数即可
	- 查看慢查询日志：cat -n /data/mysql/mysql-slow.log
	- explain 查看 SQL 语句，看下 type 字段，尽量使用索引
- 避免 MySQL 索引失效的情况  https://www.cnblogs.com/wdss/p/11186411.html
- 选择合适的事务隔离级别

10. 为什么使用索引会快

11. 所以通过上面的介绍在项目中写 SQL 需要注意些什么
https://www.cnblogs.com/wang91/p/12844696.html
https://segmentfault.com/a/1190000011617159

- 创建表的时候尽量要设置主键
- 尽量把字段设置为NOT NULL
- 使用连接(JOIN)来代替子查询(Sub-Queries)
- in 和 not in 也要慎用，否则会导致全表扫描；可以用 exists 代替 in
- 索引并不是越多越好，索引固然可以提高相应的 select 的效率，但同时也降低了 insert 及 update 的效率，因为 insert 或 update 时有可能会重建索引，所以怎样建索引需要慎重考虑，视具体情况而定。一个表的索引数最好不要超过6个，若太多则应考虑一些不常使用到的列上建的索引是否有必要。
- 尽可能的使用 varchar/nvarchar 代替 char/nchar ，因为首先变长字段存储空间小，可以节省存储空间，其次对于查询来说，在一个相对较小的字段内搜索效率显然要高些。
- 任何地方都不要使用 select * from t ，用具体的字段列表代替 * ，不要返回用不到的任何字段。 
- 尽量少用临时表，可以用 UNION 代替手动创建临时表
- 特定场景使用SQL的批处理  批量插入、批量更新
- 

12. 编程题
```java
/**
给定一个字符串数组，将字母异位词组合在一起。字母异位词指字母相同，但排列不同的字符串。
示例：
输入：["eat","tea","tan","ate","nat","bat"]
输出：
[
    ["ate","eat","tea"],
    ["nat","tam"],
    ["bat"]
]
**/

    public List<List<String>> fun(List<String> list) {
        Map<Integer, List<String>> map = new HashMap<>();

        for (String str : list) {
            int hash = getHash(str);
            System.out.println("str = " + str + ", hash = " + hash);
            if (map.get(hash) == null) {
                List<String> strList = new ArrayList<>();
                strList.add(str);
                map.put(hash, strList);
            } else {
                List<String> strList = map.get(hash);
                strList.add(str);
            }
        }

        List<List<String>> result = map.values().stream().collect(Collectors.toList());
        return result;
    }

    public int getHash(String str) {
        char[] chars = str.toCharArray();
        int hash = 0;
        for (int i = 0; i < chars.length; i++) {
            hash = hash + (chars[i] - 'a');
        }
        return hash;
    }
    
```

13. 团队介绍和答疑