1. MySQL 创建表的时候需要注意哪些
2. MySQL 每个表最大索引个数是多少
     MySQL最佳实践：https://dev.mysql.com/doc/refman/8.0/en/optimization.html
       https://dev.mysql.com/doc/refman/5.7/en/optimize-overview.html

3. Redis 缓存和锁之外，还能怎么用


4. Redis 队列和 MQ 的区别
5. RabbitMQ kafka 怎么保证高可用
6. MySQL 的聚集索引和非聚集索引怎么找数据的
7. 分布式 ID 生成器
8. 整个系统
9. 算法题：
   题1：
   ```java
       /**
     * 找出数组中元素和为指定数值的所有组合
     * 例如：
     * 数值 11
     * 数组 [1.1,2.2,3.3,5.5,5.5,7.7,10,30]
     * 结果：
     * [2.2,3.3,5.5]
     * [5.5,5.5]
     * [3.3,7.7]
     * [1.1,2.2,7.7]
     *
     * @param args
     */
   public static void main(String[] args) {
        double[] arr = {1.1, 2.2, 3.3, 5.5, 5.5, 7.7, 10, 30};
        visit(arr, 0, 0, 11, new ArrayList<>());
    }
   
    public static void visit(double[] arr, int pos, double sum, int target, List<Double> buf) {
        if (pos >= arr.length) {
            return;
        }
        if (arr[pos] > 0 && arr[pos] + sum > target) {
            return;
        }
        buf.add(arr[pos]);
        if (sum + arr[pos] == target) {
            System.out.println(buf);
        }
        visit(arr, pos + 1, sum + arr[pos], target, buf);
        buf.remove(arr[pos]);
        visit(arr, pos + 1, sum, target, buf);
    }
   ```

   题2：
   ```java
      /**
     * 題目：爬楼梯问题
     * 假设你正在爬楼梯，需要 n 阶才能到楼顶
     * 每次你可以爬 1 或 2 或 3 个台阶，你有多少种不同的方法可以爬到楼顶？输入 4 输出 7
     * <p>
     * 就是斐波那契数列问题
     *
     * @param args
     */
    public static void main(String[] args) {
   
        Scanner scanner = new Scanner(System.in);
        while (scanner.hasNext()) {
            int n = scanner.nextInt();
            //long fib1 = FibRecursion(n);
            long fib2 = FibLoop(n);
            //System.out.println(fib1);
            System.out.println(fib2);
        }
    }
   
    /**
     * 方法一：递归
     * 该方法会随着 n 的增加，计算量会急剧增大
     * 并且对于 n 特别大的情况，JVM 栈深度特别大的时候，会出现 StackOverflowError
     *
     * @param n
     * @return
     */
    public static long FibRecursion(int n) {
        if (n <= 0) {
            return 0;
        }
        if (n == 1) {
            return 1;
        }
        return FibRecursion(n - 1) + FibRecursion(n - 2) + FibRecursion(n - 3);
    }
    /**
     * 方法二：循环
     * 将递归方法换成循环
     * 时间复杂度 O(n)
     *
     * @param n
     * @return
     */
    public static long FibLoop(int n) {
        int[] fibNum = {0, 1, 2, 4};
        if (n < 4) {
            return fibNum[n];
        }
        long fib_1 = 1;
        long fib_2 = 2;
        long fib_3 = 4;
        long fib_N = 0;
        for (int i = 4; i <= n; i++) {
            fib_N = fib_1 + fib_2 + fib_3;
            fib_1 = fib_2;
            fib_2 = fib_3;
            fib_3 = fib_N;
        }
        return fib_N;
    }
   ```