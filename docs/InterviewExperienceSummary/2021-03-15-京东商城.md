1. Java集合有哪些？
2. ArrayList 和 LinkedList 区别
   - 都不是线程安全的
   - 底层结构：ArrayList 采⽤数组存储，LinkedList 采⽤链表存储
   - ArrayList 采⽤数组存储，所以插⼊和删除元素的时间复杂度受元素位置的影响
   - LinkedList 采⽤链表存储，所以对于 add(E e) ⽅法的插⼊，删除元素时间复杂度不受元素
   位置的影响，近似 O(1)，如果是要在指定位置 i 插⼊和删除元素的话（ 时间复杂度近似为 o(n)) 因为需要先移动到指定位置再插⼊
   - ArrayList 的空 间浪费主要体现在在 list 列表的结尾会预留⼀定的容量空间，⽽ LinkedList 的空间花费则体现在它的每⼀个元素都需要消耗⽐ ArrayList 更多的空间
   - LinkedList 不⽀持⾼效的随机元素访问，⽽ **ArrayList ⽀持快速访问**。快速随机访问就是通过元素的序号快速获取元素对象   
3. HashMap 底层实现原理，JDK 1.7 及职权 和 JDK 1.8 及之后，HashMap的区别
    获取table位置：(n - 1) & hash
    hash = (h = key.hashCode()) ^ (h >>> 16) 
4. HashMap 的⻓度为什么是2的幂次⽅
     为了能让 HashMap 存取⾼效，尽量较少碰撞，也就是要尽量把数据分配均匀。
       ![](https://note.youdao.com/yws/api/personal/file/47378E0852B94218818CFDC6AD69F5AB?method=download&shareKey=288c7f4ec7bb1ca1dba6b84d14335f78)
5. 用 HashMap 的时候，内存被打满了，怎么办？（线程不安全）
     **put的时候导致的多线程数据不一致**
       比如有两个线程A和B，首先A希望插入一个key-value对到HashMap中，首先计算记录所要落到的 hash桶的索引坐标，然后获取到该桶里面的链表头结点，此时线程A的时间片用完了，而此时线程B被调度得以执行，和线程A一样执行，只不过线程B成功将记录插到了桶里面，假设线程A插入的记录计算出来的 hash桶索引和线程B要插入的记录计算出来的 hash桶索引是一样的，那么当线程B成功插入之后，线程A再次被调度运行时，它依然持有过期的链表头但是它对此一无所知，以至于它认为它应该这样做，如此一来就覆盖了线程B插入的记录，这样线程B插入的记录就凭空消失了，造成了数据不一致的行为。
       **resize而引起死循环**
       这种情况发生在HashMap自动扩容时，当2个线程同时检测到元素个数超过 数组大小 × 负载因子。此时2个线程会在put()方法中调用了resize()，两个线程同时修改一个链表结构会产生一个循环链表（JDK1.7中，会出现resize前后元素顺序倒置的情况）。接下来再想通过get()获取某一个元素，就会出现死循环。
6. ConcurrentHashMap 实现原理、HashTable 的区别
7. HashSet，采用HashMap，add(value)即采用HashMap的put(value, **false**)方法
8. Synchronized 用在代码段和方法上的区别
- 修饰实例⽅法: 作⽤于当前对象实例加锁，进⼊同步代码前要获得**当前对象实例的锁**
- 修饰静态⽅法: 也就是给当前类加锁，会作⽤于类的所有对象实例 ，进⼊同步代码前要获得**当前 class 的锁**
- 修饰代码块 ：指定加锁对象，对给定对象/类加锁。synchronized(.class) 表示进⼊同步代码前要获得**当前 class 的锁**
9. Synchronized 和 Lock、ReentrantLock 的区别
- synchronized 竞争锁时会一直等待；ReentrantLock 可以尝试获取锁，并得到获取结果
- synchronized 获取锁无法设置超时；ReentrantLock 可以设置获取锁的超时时间
- synchronized 无法实现公平锁；ReentrantLock 可以满足公平锁，即先等待先获取到锁
- synchronized 控制等待和唤醒需要结合加锁对象的 wait() 和 notify()、notifyAll()；ReentrantLock 控制等待和唤醒需要结合 Condition 的 await() 和 signal()、signalAll() 方法
- synchronized 是 JVM 层面实现的；ReentrantLock 是 JDK 代码层面实现
- synchronized 在加锁代码块执行完或者出现异常，自动释放锁；ReentrantLock 不会自动释放锁，需要在 finally{} 代码块显示释放
10. 多线程
```java
public ThreadPoolExecutor(int corePoolSize,
                              int maximumPoolSize,
                              long keepAliveTime,
                              TimeUnit unit,
                              BlockingQueue<Runnable> workQueue,
                              ThreadFactory threadFactory,
                              RejectedExecutionHandler handler) {
        if (corePoolSize < 0 ||
            maximumPoolSize <= 0 ||
            maximumPoolSize < corePoolSize ||
            keepAliveTime < 0)
            throw new IllegalArgumentException();
        if (workQueue == null || threadFactory == null || handler == null)
            throw new NullPointerException();
        this.corePoolSize = corePoolSize;
        this.maximumPoolSize = maximumPoolSize;
        this.workQueue = workQueue;
        this.keepAliveTime = unit.toNanos(keepAliveTime);
        this.threadFactory = threadFactory;
        this.handler = handler;
    }
```
![](https://note.youdao.com/yws/api/personal/file/8C5226C78BC7456C91EA0BEFE639FEFF?method=download&shareKey=218b881b72206755ca79c80b543308f4)
- corePoolSize 核心线程数：表示核心线程池的大小。当提交一个任务时，如果当前核心线程池的线程个数没有达到 corePoolSize，则会创建新的线程来执行所提交的任务，即使当前核心线程池有空闲的线程。如果当前核心线程池的线程个数已经达到了corePoolSize，则不再重新创建线程。如果调用了 prestartCoreThread() 或者 prestartAllCoreThreads()，线程池创建的时候所有的核心线程都会被创建并且启动。若 corePoolSize == 0，则任务执行完之后，没有任何请求进入时，销毁线程池的线程。若 corePoolSize > 0，即使本地任务执行完毕，核心线程也不会被销毁。corePoolSize 其实可以理解为可保留的空闲线程数。
- maximumPoolSize： 表示线程池能够容纳同时执行的最大线程数。如果当阻塞队列已满时，并且当前线程池线程个数没有超过 maximumPoolSize 的话，就会创建新的线程来执行任务。注意 maximumPoolSize >= 1 必须大于等于 1。maximumPoolSize == corePoolSize ，即是固定大小线程池。实际上最大容量是由 CAPACITY 控制。
- keepAliveTime： 线程空闲时间。当空闲时间达到 keepAliveTime值时，线程会被销毁，直到只剩下 corePoolSize 个线程为止，避免浪费内存和句柄资源。默认情况，当线程池的线程数 > corePoolSize 时，keepAliveTime 才会起作用。但当 ThreadPoolExecutor 的 allowCoreThreadTimeOut 变量设置为 true 时，核心线程超时后会被回收。
- unit：时间单位。为 keepAliveTime 指定时间单位。
- workQueue 缓存队列。当请求的线程数 > corePoolSize 时，线程进入 BlockingQueue 阻塞队列。可以使用 ArrayBlockingQueue, LinkedBlockingQueue, SynchronousQueue, PriorityBlockingQueue。
- threadFactory 创建线程的工程类。可以通过指定线程工厂为每个创建出来的线程设置更有意义的名字，如果出现并发问题，也方便查找问题原因。
- handler 饱和策略。当线程池的阻塞队列已满和指定的线程都已经开启，说明当前线程池已经处于饱和状态了，那么就需要采用一种策略来处理这种情况。采用的策略有这几种：
	- AbortPolicy： 直接拒绝所提交的任务，并抛出 RejectedExecutionException 异常；
	- CallerRunsPolicy：只用调用者所在的线程来执行任务；
	- DiscardPolicy：不处理直接丢弃掉任务；
	- DiscardOldestPolicy：丢弃掉阻塞队列中存放时间最久的任务，执行当前任务
![](https://note.youdao.com/yws/api/personal/file/04E07C8FAE5E4903B637211179A6A43E?method=download&shareKey=90425d9f0b36983d26bec7eb5ddf2482)
![](https://note.youdao.com/yws/api/personal/file/C053FDA91A11401BB01CF33D98C74769?method=download&shareKey=f8b9a722e83a28c4757b4cb1ed751138)

11. CAS 
12. AQS-AbstractQueuedSynchronizer
- 引用包：java.util.concurrent.locks
- **AQS 是⼀个⽤来构建锁和同步器的框架**，使⽤ AQS 能简单且⾼效地构造出应⽤⼴泛的⼤量的同步器，⽐如我们提到的 ReentrantLock ， Semaphore ，其他的诸如 ReentrantReadWriteLock ，SynchronousQueue ， FutureTask 等等皆是基于 AQS 的。
- **AQS 核⼼思想是，如果被请求的共享资源空闲，则将当前请求资源的线程设置为有效的⼯作线程，并且将共享资源设置为锁定状态。如果被请求的共享资源被占⽤，那么就需要⼀套线程阻塞等待以及被唤醒时锁分配的机制，这个机制 AQS 是⽤ CLH 队列锁实现的，即将暂时获取不到锁的线程加⼊到队列中。**
- **CLH(Craig,Landin,and Hagersten)队列是⼀个虚拟的双向队列**（虚拟的双向队列即不存在队列实例，仅存在结点之间的关联关系）。 AQS 是将每条请求共享资源的线程封装成⼀个CLH 锁队列的⼀个结点（Node）来实现锁的分配。
![](https://note.youdao.com/yws/api/personal/file/353594FEF2914189B752827C411E6D8D?method=download&shareKey=9d9a45cbc223bf961444cf87a454d88a)
- **AQS 使⽤⼀个 int 成员变量来表示同步状态**，通过内置的 FIFO 队列来完成获取资源线程的排队⼯作。 AQS **使⽤ CAS 对该同步状态进⾏原⼦操作实现对其值的修改**。
- AQS 定义两种资源共享⽅式
  + **Exclusive（独占）**：只有⼀个线程能执⾏，如 ReentrantLock 。⼜可分为公平锁和⾮公平锁：
  	- 公平锁：按照线程在队列中的排队顺序，先到者先拿到锁
  	- ⾮公平锁：当线程要获取锁时，⽆视队列顺序直接去抢锁，谁抢到就是谁的
  + **Share（共享）**：多个线程可同时执⾏，如CountDownLatch 、 Semaphore 、 CountDownLatch 、 CyclicBarrier 、 ReadWriteLock 我们都会在后⾯讲到。

- AQS 使⽤了模板⽅法模式，⾃定义同步器时需要重写下⾯⼏个 AQS 提供的模板⽅法

```java 
isHeldExclusively()//该线程是否正在独占资源。只有⽤到condition才需要去实现它。
tryAcquire(int)//独占⽅式。尝试获取资源，成功则返回true，失败则返回false。
tryRelease(int)//独占⽅式。尝试释放资源，成功则返回true，失败则返回false。
tryAcquireShared(int)//共享⽅式。尝试获取资源。负数表示失败； 0表示成功，但没有剩余可⽤资源；正数表示成功，且有剩余资源。
tryReleaseShared(int)//共享⽅式。尝试释放资源，成功则返回true，失败则返回false。
```
- AQS 组件总结
	- Semaphore (信号量)-允许多个线程同时访问： synchronized 和 ReentrantLock 都是⼀次只允许⼀个线程访问某个资源， Semaphore (信号量)可以指定多个线程同时访问某个资源。
	- CountDownLatch （倒计时器）： CountDownLatch 是⼀个同步⼯具类，⽤来协调多个线程之间的同步。这个⼯具通常⽤来控制线程等待，它可以让某⼀个线程等待直到倒计时结束，再开始执⾏。
	- CyclicBarrier (循环栅栏)： CyclicBarrier 和 CountDownLatch ⾮常类似，它也可以实现线程间的技术等待，但是它的功能⽐ CountDownLatch 更加复杂和强⼤。主要应⽤场景和CountDownLatch 类似。 CyclicBarrier 的字⾯意思是可循环使⽤（ Cyclic ）的屏障（ Barrier ）。它要做的事情是，让⼀组线程到达⼀个屏障（也可以叫同步点）时被阻塞，直到最后⼀个线程到达屏障时，屏障才会开⻔，所有被屏障拦截的线程才会继续⼲活。 CyclicBarrier 默认的构造⽅法是 CyclicBarrier(int parties) ，其参数表示屏障拦截的线程数量，每个线程调⽤ await() ⽅法告诉 CyclicBarrier 我已经到达了屏障，然后当前线程被阻塞。

13. JUC-java.util.concurrent


13. MySQL 索引为什么用 B+ 树
- **更少的IO次数**：B+树的非叶节点只包含键，而不包含真实数据，因此每个节点存储的记录个数比B数多很多（即阶m更大），因此**B+树的高度更低**，访问时所需要的IO次数更少。此外，由于每个节点存储的记录数更多，所以对访问局部性原理的利用更好，缓存命中率更高。
- **更适于范围查询**：在B树中进行范围查询时，首先找到要查找的下限，然后对B树进行中序遍历，直到找到查找的上限；而B+树的范围查询，只需要对链表进行遍历即可。（B+树通过链表把叶子节点连接起来）
- **更稳定的查询效率**：B树的查询时间复杂度在1到树高之间(分别对应记录在根节点和叶节点)，而B+树的查询复杂度则稳定为树高，因为所有数据都在叶节点。

14. MySQL 聚集索引和非聚集索引
![](https://note.youdao.com/yws/api/personal/file/F0FEA05D1C854C4D838147A4E457740C?method=download&shareKey=e7964fbadb23db69da99c853a70b26ca)
15. MySQL 索引什么情况下失效
https://www.cnblogs.com/wdss/p/11186411.html
16. MySQL 索引类型有：唯一索引，主键索引，普通索引，全文索引
17. 延伸：Spring 事务什么时候失效

18. RabbitMQ VS kafka
**Kafka：**
 - 1.从A系统到B系统的消息没有复杂的传递规则，并且具有较高的吞吐量要求。
 - 2.需要访问消息的历史记录的场景，因为kafak是持久化消息的，所以可以通过偏移量访问到那些已经被消费的消息（前提是磁盘空间足够，kafka没有将日志文件删除）
 - 3.流处理的场景。处理源源不断的流式消息，比较典型的是日志的例子，将系统中源源不断生成的日志发送到kafka中。
**rabbit：**
 - 1.需要对消息进行更加细粒度的控制，包括一些可靠性方面的特性，比如死信队列。
 - 2.需要多种消费模式（点对点，广播，订阅发布等）
 - 3.消息需要通过复杂的路由到消费者。

19. Redis 和 Memcached 的区别

20. Redis 宕机了怎么办
21. Redis 持久化 RDB （Redis DataBase）和 AOF （Append Only File）
https://mp.weixin.qq.com/s/NAtYk-mGRia2hooBVrEIrA


20. 雪花算法
21. ES
22. MongoDB
23. 设计模式都知道哪些，介绍下怎么用的

24. Springboot 用到了哪些设计模式

25. 最终一致性方案
消费端保证幂等，如果存入redis了，但是消费者挂了，怎么处理？

​       收到消息先把messageid存库并设置过期时间，执行完成后再写库去掉过期时间。这样避免了Redis写入了，但是消费者挂了没有消费的情况。






