1. 自我介绍，闲聊
2. 编程题：满二叉树证明
     写一个方法，入参是二叉树的根节点，返回boolean，如果是满二叉树返回true，如果不是返回false
```java
    /**
     * 如果 树的节点个数 = 2^n -1 则是全二叉树，否则不是
     * 其中 n 是树的深度
     *
     * @param root
     * @return
     */
    public static boolean isFullBinTree(TreeNode root) {
        if (root == null) {
            return false;
        }
        if (root.right == null && root.left == null) {
            return true;
        }

        List<Integer> values = new ArrayList<>();
        int deepAndValues = getDeepAndValues(root, values);
        if (values.size() == (1 << deepAndValues) - 1) {
            return true;
        }

        return false;
    }

    /**
     * 获取深度和所有节点
     *
     * @param treeNode
     * @param values
     * @return
     */
    public static int getDeepAndValues(TreeNode treeNode, List<Integer> values) {

        // treeNode为null，则由treeNode求得的父结点高度为0
        if (treeNode == null) {
            return 0;
        }
        values.add(treeNode.val);
        //由左子树求当前结点treeNode的高度
        int leftHeight = getDeepAndValues(treeNode.left, values);
        //由右子树求当前结点treeNode的高度
        int rightHeight = getDeepAndValues(treeNode.right, values);
        //当前结点的高度+1 为 父结点的高度
        int height = leftHeight >= rightHeight ? leftHeight + 1 : rightHeight + 1;
        return height;

    }
```
3. CAP理论介绍下，为什么不能C、A、P 同时满足，是否必须包含P 为什么
4. MySQL 的日志，binlog、undolog、redolog，介绍下？都是什么层面的日志，作用是什么，原理是什么
5. 订单表，特别大，包含课程id、学生id等信息，（不考虑分库分表的情况），因为没有课程是有配额的，卖完了就不再买了，防止超卖的情况。所以每次下单的时候回去全表查询count（）课程的已支付的个数，性能瓶颈，有没有优化方案
