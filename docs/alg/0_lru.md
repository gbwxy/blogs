https://zhuanlan.zhihu.com/p/150986952
https://www.jianshu.com/p/d533d8a66795
https://www.iteye.com/blog/flychao88-1977653


## LRU原理
![](https://note.youdao.com/yws/api/personal/file/F89ADAD3C79240C7B23CE793E7E98F3F?method=download&shareKey=bd95c66a0c3de217e5832f438d71d4ac)
- 新数据插入到链表头部；
- 每当缓存命中（即缓存数据被访问），则将数据移到链表头部；
- 当链表满的时候，将链表尾部的数据丢弃。

【命中率】
当存在热点数据时，LRU的效率很好，但偶发性的、周期性的批量操作会导致LRU命中率急剧下降，缓存污染情况比较严重。
【复杂度】
实现简单。
【代价】
命中时需要遍历链表，找到命中的数据块索引，然后需要将数据移到头部。

## LRU-K原理
LRU-K中的K代表最近使用的次数，因此LRU可以认为是LRU-1。LRU-K的主要目的是为了解决LRU算法“缓存污染”的问题，其核心思想是将“最近使用过1次”的判断标准扩展为“最近使用过K次”。

## LUR-Two queues原理

## LRU-Multi Queue原理
MQ算法根据访问频率将数据划分为多个队列，不同的队列具有不同的访问优先级，其核心思想是：优先缓存访问次数多的数据。
MQ算法将缓存划分为多个LRU队列，每个队列对应不同的访问优先级。访问优先级是根据访问次数计算出来的，例如
详细的算法结构图如下，Q0，Q1....Qk代表不同的优先级队列，Q-history代表从缓存中淘汰数据，但记录了数据的索引和引用次数的队列：
![](https://note.youdao.com/yws/api/personal/file/81F361377F3142B19AA59459EC7D226B?method=download&shareKey=2157cc26fb82a9f2347beffa1c66eed3)

如上图，算法详细描述如下：
- 新插入的数据放入Q0；
- 每个队列按照LRU管理数据；
- 当数据的访问次数达到一定次数，需要提升优先级时，将数据从当前队列删除，加入到高一级队列的头部；
- 为了防止高优先级数据永远不被淘汰，当数据在指定的时间里访问没有被访问时，需要降低优先级，将数据从当前队列删除，加入到低一级的队列头部；
- 需要淘汰数据时，从最低一级队列开始按照LRU淘汰；每个队列淘汰数据时，将数据从缓存中删除，将数据索引加入Q-history头部；
- 如果数据在Q-history中被重新访问，则重新计算其优先级，移到目标队列的头部；
- Q-history按照LRU淘汰数据的索引。

【命中率】
MQ降低了“缓存污染”带来的问题，命中率比LRU要高。
【复杂度】
MQ需要维护多个队列，且需要维护每个数据的访问时间，复杂度比LRU高。
【代价】
MQ需要记录每个数据的访问时间，需要定时扫描所有队列，代价比LRU要高。
注：虽然MQ的队列看起来数量比较多，但由于所有队列之和受限于缓存容量的大小，因此这里多个队列长度之和和一个LRU队列是一样的，因此队列扫描性能也相近。

